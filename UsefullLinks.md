### Links
[Difference between std::lock_guard and std::unique_lock](http://jakascorner.com/blog/2016/02/lock_guard-and-unique_lock.html)   
[What is dynamic casting in C++?](https://www.educative.io/edpresso/what-is-dynamic-casting-in-cpp)   
[Runtime vs. Compile time](https://stackoverflow.com/questions/846103/runtime-vs-compile-time)    
### Questions interview

1) #### Зачем нужен виртуальный деструктор?
2) #### Что стоит помнить при использовании исключений в конструкторе объекта?
3) #### Для каких целей применяется ключевое слово const?
4) #### В чем разница между struct и class?
5) #### В чем отличие vector от deque?
6) #### В чем отличие malloc от new?
7) #### В чем различия между dynamic_cast и reinterpret_cast и static_cast?
8) #### Для чего нужен аллокатор и как создать свой собственный аллокатор?
9) #### Сколько в памяти занимает произвольная структура?   
    - sizeof всех членов  
    - остаток для выравнивания (по умолчанию выравнивание 4 байта) 
    - sizeof указателя на vtable (если есть виртуальные функции)
    - указатели на классы предков, от которых было сделано виртуальное наследование (размер указателя * количество классов)
10) #### В чем разница между массивом и списком?
11) #### Что можно сказать о delete this?
12) #### В чем основное различие между деструктором и оператором delete?
13) #### В чем отличия указателя и ссылки?
14) #### В чём суть множественного наследования? Какие проблемы могут возникнуть при его использовании? Как их преодолеть?
15) #### Как сгенерировать pure virtual function call исключение?
    - Ответ: Нужно вызвать чисто виртуальный метод в конструкторе родительского класса т.е. до создания дочернего, в котором этот метод реализован. Т.к. современный компилятор не даст это сделать напрямую, то нужно будет использовать промежуточный метод.
17) #### Как защитить объект от копирования?
18) #### Умные указатели. Какие бывают и в чем отличия?
    - Ответ: auto_ptr Так как данный умный указатель реализует подход разрушающего копирования, то при присвоении его другому умному указателю оригинальный потеряет свое значение. А так же его нельзя использовать в стандартных STL контейнерах.   
        Также ввиду того, что в деструкторе auto_ptr вызывается оператор delete, нельзя хранить объекты созданные при помощи new[](). Именно из-за этого нюанса boost предоставляет умные указатели в двух вариантах, для просто объекта и их коллекции, например, shared_ptr и shared_array.
19) #### Для чего используется ключевое слово volatile?
    - Ответ: Для указания компилятору, что доступ к переменной может осуществляться из мест, неподконтрольных ему. А как следствие, что работу с данной переменной не нужно подвергать разного рода оптимизациям.

20) #### Каким свойством должен обладать объект, чтобы его можно было добавить в ассоциативные контейнеры(set) в качестве ключа?
    - Ответ: Т.к. значения в ассоциативных контейнерах хранятся отсортированными, то объект должен реализовывать оператор сравнения <, а остальные операторы сравнения могут быть выражены через него.
21) #### Что дают разные модификаторы при наследовании?
22) #### Что такое инкапсуляция?
23) #### Что такое полиморфизм?
24) #### Что такое чисто виртуальный метод и абстрактный класс?
25) #### Для чего используется вызов throw без аргументов?
    - Ответ: Для повторного возбуждения предыдущего исключения и направления его следующему обработчику.
26) #### В чем различия между delete и delete[]?
    - Ответ: delete предназначен для уничтожения объектов, память под которые выделена при помощи new(). delete[] для объектов выделенных при помощи оператора new[]().
27) #### Для чего используется ключевое слово volatile?
